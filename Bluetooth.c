//*****************************************************************************
// Copyright (c) 2014 Texas Instruments Incorporated.  All rights reserved.
// Software License Agreement
// 
//   Redistribution and use in source and binary forms, with or without
//   modification, are permitted provided that the following conditions
//   are met:
// 
//   Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.
// 
//   Redistributions in binary form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in the
//   documentation and/or other materials provided with the  
//   distribution.
// 
//   Neither the name of Texas Instruments Incorporated nor the names of
//   its contributors may be used to endorse or promote products derived
//   from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// This file was automatically generated by the Tiva C Series PinMux Utility
// Version: 1.0.4
//
//*****************************************************************************

//PinMux libraries
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <math.h>
#include "Bluetooth.h"
#include "inc/hw_types.h"
#include "inc/hw_memmap.h"
#include "inc/hw_gpio.h"
#include "driverlib/sysctl.h"
#include "driverlib/pin_map.h"
#include "driverlib/rom_map.h"
#include "driverlib/gpio.h"


//User added Libraries
#include "inc/tm4c123gh6pm.h"
#include "driverlib/uart.h"
#include "driverlib/interrupt.h"
#include "utils/uartstdio.h"
#include "driverlib/interrupt.h"
#include "driverlib/hibernate.h"
#include <inttypes.h>


//Sensor Libraries
#include "sensorlib/hw_mpu9150.h"
#include "sensorlib/hw_ak8975.h"
#include "sensorlib/i2cm_drv.h"
#include "sensorlib/ak8975.h"
#include "sensorlib/mpu9150.h"
#include "sensorlib/comp_dcm.h"
#include "sensorlib/hw_bmp180.h"
#include "sensorlib/bmp180.h"
#include "driverlib/sysctl.h"
#include "driverlib/systick.h"

//pwm library
#include "driverlib/pwm.h"

//*****************************************************************************
//This project will use I2C3(PD0 SCL, PD1 SCA) for the Sensorhub Gyroscope and Pressure sensor, UART1(PB0 RX, PB1 TX) for the HC-06 Bluetooth module,
//Potentially UART0 and the terminal for testing purposes, though this can be disabled in the later stages of testing to save time. Pins PF1-PF3 will
//be made output for LED indication purposes.
//
//The Gyroscope will be used to calculate Euler angles (roll, pitch, yaw), the pressure sensore will be used to calculate altitude via pressure
//(this is suprisingly good at calculating altitude). PID will be used on both and a button will be on the app that enables altitude hold mode.
//When the user goes to move the drone up or down, the desired altitude will be increased by a small linear amount that will have to be toyed with.
//We can probably use 1 Tiva module actually. Bluetooth and gyroscope/pressure sensor data will be on an interrupt, with the gyroscope/pressure sensor 
//data taking priority.
//*****************************************************************************

//method prototypeS

//Basic GPIO  functions
void GPIOIntInit(void);
void GPIOBInterruptHandler(void);

// UART functions
void UARTClockInit(int BaudRate);
void UART0_Init(void);
void UARTInterruptInit(void);
void UARTInterruptHandler(void);

//I2C functions
void I2C_Init(void);

//Sensorhubfunctions
void Gyro_Init(void);
void GyroCallbackFunction(void *CallbackData, uint_fast8_t status);	//this will be called when the sensurhub returns with data.
void PressureCallbackFunction(void* pvCallbackData, uint_fast8_t ui8Status);
void MPU9150I2CIntHandler(void);
void ConfigureGyro(void);
void PrintSensorInfo(void);
void Pressure_Init(void);

//Clock/Hibernation functions
void Hibernation_Init(void);												//Hibernation will be used because it has a dedicated clock for the RTC
uint32_t GetCurrentTime(void);

void PID(void);
void pwmInit(void);


//Global Variables
tI2CMInstance I2CM;			//global I2C instance for I2C master driver
tMPU9150 sensorDriver;	//global instance for the ISL29023 Sensor Driver
tBMP180  pressureDriver;	//pressure sensor driver
tCompDCM DCMManager;		//global instance of DCM state manager
//A skip count may be needed in the future to slow down rate of data transfer

//primary PID Variables

volatile uint_fast8_t sensorInfo = 0;	//This is a flag for when the sensorHub returns with data. The while loop does the bulk of the calculations
volatile uint_fast8_t pressureInfo = 0;	//flag for the pressure sensor callback function
																	//under this flag. Volatile so that the compilor doesn't make any nasty assumptions
volatile uint_fast8_t sensorError;

int j = 0;												//itterative variable
int starting = 1;									//This variable is to indicate that this is the first time the program has run
int yawStarting = 1;							//This variable is to set yaw to the current angle if it's the first time the PID algorithm has run
float gyroX, gyroY, gyroZ, roll, pitch, yaw, alt, accelX, desiredRoll=-2, desiredYaw=0, desiredPitch=0, desiredAlt, accelY, accelZ,magX, magY, magZ;
uint8_t color = 0x00;
int count = 0;
int maxangle = 90; 			//This is 90 because if the drone is 90 degrees, we are pretty much fucked. This only applies to roll and pitch. Not yaw.
uint32_t startTime = 0; 				//The start time of the drone
float lastError[4] = {0, 0, 0, 0};
float error[4] = {0, 0, 0, 0};
float errorSum[4] = {0,0,0};
int PIDoutput[4] = {0,0,0,0};		//to store the output of he PID algorithm but this is not what we use for the pwm
float temp = 0;
float	pressure = 0;


float kp[4] = {1.0f,1.0f,0.0f,0.0f};							//Proportional PID cooeficient, [Roll, Pitch, Yaw, Alttitude]
float kd[4] = {0.0f,0.0f,0.0f,0.0f};							//derivitive PID cooeficient		Yaw and altitude are done differently than roll and pitch
float ki[4] = {0.0f,0.0f,0.0f,0.0f};							//integral PID cooefecient

uint32_t now = 0;
uint32_t last = 0;

float deltat = 0;

int pwmInput[4] = {0,0,0,0};							//Roll, Pitch, Yaw, Alttitude(adds to all motors)

volatile unsigned long ui8Adjust = 0;

volatile unsigned long ui32PWMClock = 0;
volatile unsigned long PWM_FREQUENCY = 0;
volatile unsigned long ui32Load = 0;

bool start = false;
//*********************** NOTE ******************************
//The Kp starts out as 1 for tuning. Once we find a relitively stable Kp we can start adding ip and then a very small amount of dp

void GPIOBInterruptHandler(void){
	long status = GPIOIntStatus(GPIO_PORTB_BASE, true);			//get the Interrupt status of GPIOB pin 2
	GPIOIntClear(GPIO_PORTB_BASE, status);
	
	if(status & GPIO_PIN_2){
		MPU9150DataRead(&sensorDriver, GyroCallbackFunction, &sensorDriver);		//retrieave the data from the sensorhub
	}
}

void GPIOIntInit(void){
	  // Enables GPIO B, which is used for the sensor hub interupt
    
    GPIOPinTypeGPIOInput(GPIO_PORTB_BASE, GPIO_PIN_2);
    GPIOIntEnable(GPIO_PORTB_BASE, GPIO_PIN_2);
    GPIOIntTypeSet(GPIO_PORTB_BASE, GPIO_PIN_2, GPIO_FALLING_EDGE);
    IntEnable(INT_GPIOB);
}


void MPU9150AppI2CWait(char *pcFilename, uint_fast32_t ui32Line)
{

    while((sensorInfo == 0) && (sensorError == 0))
    {
				//wait
			
    }


    if(sensorInfo)
    {
        //we don't handle any errors atm, but considering the configuration we shouldn't need to
    }

    //
    // clear the data flag for next use.
    //
    sensorInfo = 0;
}


void pwmInit(void)
{
// PWM settings
PWM_FREQUENCY = 400;
ui8Adjust = 440;

SysCtlPWMClockSet(SYSCTL_PWMDIV_64);


// PWM PB4, motor A
GPIOPinTypePWM(GPIO_PORTB_BASE, GPIO_PIN_4);
GPIOPinConfigure(GPIO_PB4_M0PWM2);

// PWM PB5, motor B
GPIOPinTypePWM(GPIO_PORTB_BASE, GPIO_PIN_5);
GPIOPinConfigure(GPIO_PB5_M0PWM3);

// PWM PE4, motor C
GPIOPinTypePWM(GPIO_PORTE_BASE, GPIO_PIN_4);
GPIOPinConfigure(GPIO_PE4_M0PWM4);

// PWM PE5, motor D
GPIOPinTypePWM(GPIO_PORTE_BASE, GPIO_PIN_5);
GPIOPinConfigure(GPIO_PE5_M0PWM5);

// PWM clk and frequency
ui32PWMClock = SysCtlClockGet() / 64;
ui32Load = (ui32PWMClock / PWM_FREQUENCY) - 1;
PWMGenConfigure(PWM0_BASE, PWM_GEN_0, PWM_GEN_MODE_DOWN|PWM_GEN_MODE_NO_SYNC);
PWMGenPeriodSet(PWM0_BASE, PWM_GEN_0, ui32Load);

PWMGenConfigure(PWM0_BASE, PWM_GEN_1, PWM_GEN_MODE_DOWN|PWM_GEN_MODE_NO_SYNC);
PWMGenPeriodSet(PWM0_BASE, PWM_GEN_1, ui32Load);

PWMGenConfigure(PWM0_BASE, PWM_GEN_2, PWM_GEN_MODE_DOWN|PWM_GEN_MODE_NO_SYNC);
PWMGenPeriodSet(PWM0_BASE, PWM_GEN_2, ui32Load);

PWMGenConfigure(PWM0_BASE, PWM_GEN_3, PWM_GEN_MODE_DOWN|PWM_GEN_MODE_NO_SYNC);
PWMGenPeriodSet(PWM0_BASE, PWM_GEN_3, ui32Load);


// PWM 2 and 3
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, (ui32PWMClock / 500));	//Sets Upper Bounds of the PWM pulse witdth
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, (ui32PWMClock / 500));
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_4, (ui32PWMClock / 500));
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_5, (ui32PWMClock / 500));

PWMOutputState(PWM0_BASE, PWM_OUT_2_BIT, true);
PWMOutputState(PWM0_BASE, PWM_OUT_3_BIT, true);
// PWM 4 and 5
PWMOutputState(PWM0_BASE, PWM_OUT_4_BIT, true);
PWMOutputState(PWM0_BASE, PWM_OUT_5_BIT, true);

PWMGenEnable(PWM0_BASE, PWM_GEN_0);
PWMGenEnable(PWM0_BASE, PWM_GEN_1);
PWMGenEnable(PWM0_BASE, PWM_GEN_2);
PWMGenEnable(PWM0_BASE, PWM_GEN_3);

PWMSyncTimeBase(PWM0_BASE,PWM_GEN_0_BIT|PWM_GEN_1_BIT|PWM_GEN_2_BIT|PWM_GEN_3_BIT);		//synchronize pwm output
PWMSyncUpdate(PWM0_BASE,PWM_GEN_0_BIT|PWM_GEN_1_BIT|PWM_GEN_2_BIT|PWM_GEN_3_BIT);

SysCtlDelay(16000000);
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, (ui32PWMClock / 1000));//Sets Lower Bounds of the PWM pulse witdth
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, (ui32PWMClock / 1000));
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_4, (ui32PWMClock / 1000));
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_5, (ui32PWMClock / 1000));

SysCtlDelay(16000000);
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, (ui32PWMClock / 1000));//Set the pwm to minimum to start with
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, (ui32PWMClock / 1000));
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_4, (ui32PWMClock / 1000));
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_5, (ui32PWMClock / 1000));
}

void ConfigureGyro(void){
    //
    // Write application specifice sensor configuration such as filter settings
    // and sensor range settings.
    //
		//pui8Data is a buffer in MPU9150 that stores the write data
    sensorDriver.pui8Data[0] = MPU9150_CONFIG_DLPF_CFG_44_42;								//configures the internal lowpass filter. This is a fairly narrow bandwith and may have a notable delay
    sensorDriver.pui8Data[1] = MPU9150_GYRO_CONFIG_FS_SEL_250;							// Sets FS, the range of output. Ranges from +/- 250 to +/- 2,000
    sensorDriver.pui8Data[2] = (MPU9150_ACCEL_CONFIG_ACCEL_HPF_5HZ |				// sets and enables the accel highpass filter and FS, the range of the accel
                                  MPU9150_ACCEL_CONFIG_AFS_SEL_2G);
    MPU9150Write(&sensorDriver, MPU9150_O_CONFIG, sensorDriver.pui8Data, 3,
                 GyroCallbackFunction, &sensorDriver);
	
		MPU9150AppI2CWait(__FILE__, __LINE__);
	
		    //
    // Configure the data ready interrupt pin output of the MPU9150.
    //
    sensorDriver.pui8Data[0] = MPU9150_INT_PIN_CFG_INT_LEVEL |
                                    MPU9150_INT_PIN_CFG_INT_RD_CLEAR |
                                    MPU9150_INT_PIN_CFG_LATCH_INT_EN;
    sensorDriver.pui8Data[1] = MPU9150_INT_ENABLE_DATA_RDY_EN;
    MPU9150Write(&sensorDriver, MPU9150_O_INT_PIN_CFG,
                 sensorDriver.pui8Data, 2, GyroCallbackFunction,
                 &sensorDriver);
								 
		MPU9150AppI2CWait(__FILE__, __LINE__);
		
		    // Initialize the DCM system. 50 hz sample rate.
    // accel weight = .2, gyro weight = .8, mag weight = .2
    //
    CompDCMInit(&DCMManager, 1.0f / 50.0f, 0.2f, 0.6f, 0.2f);								//This is the DCM Manager used to calculate Euler angles
}

void PrintSensorInfo(void){									//this code is taken from the gyroscope example to print gyroscope data
		int_fast32_t i32IPart[16], i32FPart[16];
		uint_fast32_t ui32Idx;
						
						float pfData[12] = {accelX, accelY, accelZ, gyroX, gyroY, gyroZ, magX, magY, magZ, roll, pitch, yaw};
            for(ui32Idx = 0; ui32Idx < 12; ui32Idx++)
            {
                //
                // Conver float value to a integer truncating the decimal part.
                //
                i32IPart[ui32Idx] = (int32_t) pfData[ui32Idx];

                //
                // Multiply by 1000 to preserve first three decimal values.
                // Truncates at the 3rd decimal place.
                //
                i32FPart[ui32Idx] = (int32_t) (pfData[ui32Idx] * 1000.0f);

                //
                // Subtract off the integer part from this newly formed decimal
                // part.
                //
                i32FPart[ui32Idx] = i32FPart[ui32Idx] -
                                    (i32IPart[ui32Idx] * 1000);

                //
                // make the decimal part a positive number for display.
                //
                if(i32FPart[ui32Idx] < 0)
                {
                    i32FPart[ui32Idx] *= -1;
                }
            }

            //
            // Print the acceleration numbers in the table.
            //
            UARTprintf("\033[5;17H%3d.%03d", i32IPart[0], i32FPart[0]);
            UARTprintf("\033[5;40H%3d.%03d", i32IPart[1], i32FPart[1]);
            UARTprintf("\033[5;63H%3d.%03d", i32IPart[2], i32FPart[2]);

            //
            // Print the angular velocities in the table.
            //
            UARTprintf("\033[7;17H%3d.%03d", i32IPart[3], i32FPart[3]);
            UARTprintf("\033[7;40H%3d.%03d", i32IPart[4], i32FPart[4]);
            UARTprintf("\033[7;63H%3d.%03d", i32IPart[5], i32FPart[5]);

            //
            // Print the magnetic data in the table.
            //
            UARTprintf("\033[9;17H%3d.%03d", i32IPart[6], i32FPart[6]);
            UARTprintf("\033[9;40H%3d.%03d", i32IPart[7], i32FPart[7]);
            UARTprintf("\033[9;63H%3d.%03d", i32IPart[8], i32FPart[8]);

            //
            // Print the Eulers in a table.
            //
            UARTprintf("\033[14;17H%3d.%03d", i32IPart[9], i32FPart[9]);
            UARTprintf("\033[14;40H%3d.%03d", i32IPart[10], i32FPart[10]);
            UARTprintf("\033[14;63H%3d.%03d", i32IPart[11], i32FPart[11]);
}


void GyroCallbackFunction(void *CallbackData, uint_fast8_t status){

	if(status == I2CM_STATUS_SUCCESS){		//do the bulk of the work in the main loop when this is 1
		sensorInfo = 1;
	}
	sensorError = status;									//If there's an I2C error set this flag and print an error message
	
}

void Gyro_Init(void){
																											//Initializes the MPU9150
    MPU9150Init(&sensorDriver, &I2CM, 0x68,						//0x68 is the MPU9150 I2C address
                GyroCallbackFunction, &sensorDriver);
}

void I2C_Init(void){																	

    SysCtlPeripheralEnable(SYSCTL_PERIPH_I2C3);				//The Sensorhub uses this I2C module and there's really no way around it
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);			

    //
    // Configure the pin muxing for I2C3 functions on port D0 and D1.
    //
    GPIOPinConfigure(GPIO_PD0_I2C3SCL);
    GPIOPinConfigure(GPIO_PD1_I2C3SDA);

    //
    // Select the I2C function for these pins.  This function will also
    // configure the GPIO pins pins for I2C operation, setting them to
    // open-drain operation with weak pull-ups.  Consult the data sheet
    // to see which functions are allocated per pin.
    //
    GPIOPinTypeI2CSCL(GPIO_PORTD_BASE, GPIO_PIN_0);
    GPIOPinTypeI2C(GPIO_PORTD_BASE, GPIO_PIN_1);
	
	    //
    // Configure and Enable the GPIO interrupt. Used for INT signal from the
    // MPU9150
    //
    GPIOPinTypeGPIOInput(GPIO_PORTB_BASE, GPIO_PIN_2);
    GPIOIntEnable(GPIO_PORTB_BASE, GPIO_PIN_2);
    GPIOIntTypeSet(GPIO_PORTB_BASE, GPIO_PIN_2, GPIO_FALLING_EDGE);
    IntEnable(INT_GPIOB);
		

    I2CMInit(&I2CM, I2C3_BASE, INT_I2C3, 0xff, 0xff,				//Initialize I2C
             SysCtlClockGet());
						 
}

uint32_t GetCurrentTime(void){															
return HibernateRTCGet()*(uint32_t)100000.0f + HibernateRTCSSGet();		//RTC get returns Seconds and sub seconds. This concatinates them into a single number
}

void Hibernation_Init(void){
  
	SysCtlPeripheralEnable(SYSCTL_PERIPH_HIBERNATE);		//enable hibernate periph
	HibernateEnableExpClk(SysCtlClockGet());						//enables the hibernate using the system clock
	MAP_SysCtlDelay(5000);
	HibernateClockConfig(HIBERNATE_OSC_LOWDRIVE);				//I'm avoiding the use of the Oscillator that the documentation discourages
	HibernateRTCEnable();																//obv, enabling Hibernate RTC
	HibernateRTCSet(0);																	//making sure the start time of the drone is 0
	HibernateIntClear(HibernateIntStatus(false));				//resets hibernate state
	startTime = HibernateRTCGet() + HibernateRTCSSGet();
}

void
MPU9150I2CIntHandler(void)
{
    //
    // Pass through to the I2CM interrupt handler provided by sensor library.
    // This is required to be at application level so that I2CMIntHandler can
    // receive the instance structure pointer as an argument.
    //
    I2CMIntHandler(&I2CM);
}

void stop(void){																							//This function gradually decreases the speed of the motors to prevent launching props
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, (ui32PWMClock / 900));
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, (ui32PWMClock / 900));
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_4, (ui32PWMClock / 900));
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_5, (ui32PWMClock / 900));
	SysCtlDelay(1600000);
	
	PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, (ui32PWMClock / 950));
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, (ui32PWMClock / 950));
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_4, (ui32PWMClock / 950));
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_5, (ui32PWMClock / 950));
	
		SysCtlDelay(1600000);
	
	PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, (ui32PWMClock / 980));
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, (ui32PWMClock / 980));
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_4, (ui32PWMClock / 980));
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_5, (ui32PWMClock / 980));
	
		SysCtlDelay(1600000);
	
	PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, (ui32PWMClock / 1000));
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, (ui32PWMClock / 1000));
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_4, (ui32PWMClock / 1000));
PWMPulseWidthSet(PWM0_BASE, PWM_OUT_5, (ui32PWMClock / 1000));
start = false;																			//The PID algorithm should no longer set PWM values


}
	
	

void
PortFunctionInit(void)
{
	
		// Setting the main clock to be 40 MHz. If this is too slow 80Mhz will be used
		SysCtlClockSet(SYSCTL_SYSDIV_5|SYSCTL_USE_PLL|SYSCTL_OSC_MAIN|SYSCTL_XTAL_16MHZ);
    //
    // Enable Peripheral Clocks 
    //
	
		MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOC);

		SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM0);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_UART1);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
		SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);
		SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
		
	
		    //
    // Enable pin PB4 for PWM0 M0PWM2
    //
    GPIOPinConfigure(GPIO_PB4_M0PWM2);
    GPIOPinTypePWM(GPIO_PORTB_BASE, GPIO_PIN_4);
		
		    //
    // Enable pin PB5 for PWM0 M0PWM3
    //
    GPIOPinConfigure(GPIO_PB5_M0PWM3);
    GPIOPinTypePWM(GPIO_PORTB_BASE, GPIO_PIN_5);

    //
    // Enable pin PE4 for PWM0 M0PWM4
    //
    GPIOPinConfigure(GPIO_PE4_M0PWM4);
    GPIOPinTypePWM(GPIO_PORTE_BASE, GPIO_PIN_4);
		
		    //
    // Enable pin PE5 for PWM0 M0PWM5
    //
    GPIOPinConfigure(GPIO_PE5_M0PWM5);
    GPIOPinTypePWM(GPIO_PORTE_BASE, GPIO_PIN_5);

    //
    // Enable pin PB0 for UART1 U1RX
    //
    MAP_GPIOPinConfigure(GPIO_PB0_U1RX);
    MAP_GPIOPinTypeUART(GPIO_PORTB_BASE, GPIO_PIN_0);

    //
    // Enable pin PB1 for UART1 U1TX
    //
    MAP_GPIOPinConfigure(GPIO_PB1_U1TX);
    MAP_GPIOPinTypeUART(GPIO_PORTB_BASE, GPIO_PIN_1);
		
		
		//Initialize everything
		
		UART0_Init();
		UARTClockInit(9600);
		GPIOIntInit();
		UARTInterruptInit();
		UART0_Init();
		I2C_Init();
		Gyro_Init();
		ConfigureGyro();
		Pressure_Init();
		Hibernation_Init();
		
}

void UARTInterruptHandler(void){
	uint8_t flag;									//interrupt flag
	uint8_t c;										//this character
		//UARTprintf("RIP");
	flag = UARTIntStatus(UART1_BASE,true); 	//get flag data and store in flag
	UARTIntClear(UART1_BASE, flag);					//clear the flag
	
	c = UARTCharGet(UART1_BASE);						//load the recieved char into c
	
	if(c == 's'){																			//start the propellors
		start = true;
		
	}
	if(c == 'x'){																			//Stop the propellors
		stop();
		
	}
	

	
	UARTCharPut(UART0_BASE, c);

}

void UARTInterruptInit(void){												//The UART Interupt. This actually triggers if the Tiva is touched the wrong way.
UARTIntEnable(UART1_BASE, UART_INT_RX|UART_INT_RT);
IntEnable(INT_UART1);
IntMasterEnable();
}
void UARTClockInit(int BaudRate){										//Init the UART Clock
	UARTConfigSetExpClk(UART1_BASE, SysCtlClockGet(), BaudRate,(UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE | UART_CONFIG_PAR_NONE));
	
}

void UART0_Init(void) {														//Initialize UART0 for testing purposes

    SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);

    GPIOPinConfigure(GPIO_PA0_U0RX);
    GPIOPinConfigure(GPIO_PA1_U0TX);
    GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);


    UARTConfigSetExpClk(UART0_BASE, SysCtlClockGet(), 115200,
        (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE | UART_CONFIG_PAR_NONE));
		UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);
		UARTStdioConfig(0, 115200, 16000000);
}

void Pressure_Init(void){														//Initialize the BMP180
    BMP180Init(&pressureDriver, &I2CM, 0x77,
               PressureCallbackFunction, &pressureDriver);
}

void PressureCallbackFunction(void* pvCallbackData, uint_fast8_t ui8Status){			//This is called when the pressure sensor has info to pass
			if(ui8Status == I2CM_STATUS_SUCCESS)
    {
        pressureInfo = 1;
    }
}

void PID(void){

            //
            // Get Euler data. (Roll Pitch Yaw)
            //
						now = GetCurrentTime();
						deltat = ((float)(now-last)/10000.0f);
            CompDCMComputeEulers(&DCMManager, &roll, &pitch,
                                 &yaw);

						
						alt = 44330.0f * (1.0f - powf(pressure / 101325.0f, 1.0f / 5.255f));						

            //
            // Convert Eulers to degrees. 180/PI = 57.29...
            // Convert Yaw to 0 to 360 to approximate compass headings.
            //
            roll *= 57.29577951308f;
            pitch *= 57.29577951308f;
            yaw *= 57.29577951308f;
            
						
						if(yawStarting == 1){
							yawStarting = 0;
							desiredYaw = yaw;
							desiredAlt = alt;
							
						}
						

						
						//******************PID BEINGS******************//
					//find error at the moment
					error[0] = desiredRoll - roll;
					error[1] = desiredPitch - pitch;
					error[2] = desiredYaw - yaw;
					error[3] = desiredAlt - alt;
					
				  
					for(j = 0;j < 4;j++){
						errorSum[j] += ki[j]*error[j]*deltat;
						
						PIDoutput[j] = (int)(kp[j]*error[j] + errorSum[j] + kd[j]*(error[j]-lastError[j])/deltat);
						lastError[j] = error[j];
					}
					
					pwmInput[0] = (800 - (-PIDoutput[0] - PIDoutput[1] - PIDoutput[2] - PIDoutput[3])); 	//E5
					pwmInput[1] = (800 - (-PIDoutput[0] + PIDoutput[1] +PIDoutput[2] - PIDoutput[3]));	//E4
					pwmInput[2] = (800 - (PIDoutput[0] - PIDoutput[1] +PIDoutput[2]  - PIDoutput[3]));	//B5
					pwmInput[3] = (800 - (PIDoutput[0] + PIDoutput[1] -PIDoutput[2]  - PIDoutput[3]));	//B4
																										
					for(j = 0;j<4;j++){													//Make sure all pwm values are withing range
					if(pwmInput[j] < 500){
							pwmInput[j] = 500;
					}
					if(pwmInput[j] > 1000){
							pwmInput[j] = 1000;
					}
					}
					if(start){			//Finally, if running, set the speed of each motor to the coresponding motor
					PWMPulseWidthSet(PWM0_BASE, PWM_OUT_2, ui32PWMClock / pwmInput[3]);
					PWMPulseWidthSet(PWM0_BASE, PWM_OUT_3, ui32PWMClock / pwmInput[2]);
					PWMPulseWidthSet(PWM0_BASE, PWM_OUT_4, ui32PWMClock / pwmInput[1]);
					PWMPulseWidthSet(PWM0_BASE, PWM_OUT_5, ui32PWMClock / pwmInput[0]);
					}
					

						last = now;
					

					
					
}


int main(void){
	if(starting){					//If the interupt starts main over again we don't want the setup to run again
		PortFunctionInit();
	}
	
	
	pwmInit();
	
	last = GetCurrentTime();
	uint32_t greatest = 0;
	UARTFlushTx(false);
	UARTFlushRx();				//Flushing UART info
	
	while(1){
		if(pressureInfo == 0)
			{			//prep pressure info retrieval
				BMP180DataRead(&pressureDriver, PressureCallbackFunction, &pressureDriver);
			}
		
		
		if(sensorInfo == 1)
			{
				
				sensorInfo = 0;
				
				
			if(pressureInfo == 1){
				
					pressureInfo = 0;				//Retrieve Pressure Info
					BMP180DataTemperatureGetFloat(&pressureDriver, &temp);
					BMP180DataPressureGetFloat(&pressureDriver, &pressure);
				}
			
			//************Get angles**************//
			MPU9150DataAccelGetFloat(&sensorDriver, &accelX, &accelY, &accelZ);
			MPU9150DataGyroGetFloat(&sensorDriver, &gyroX, &gyroY, &gyroZ);
			MPU9150DataMagnetoGetFloat(&sensorDriver, &magX, &magY, &magZ);
			//This next brick is to seed the DCM so that it can calculate Euler angles
			if(starting){
				starting = 0;
				    CompDCMMagnetoUpdate(&DCMManager, magX, magY,magZ);
            CompDCMAccelUpdate(&DCMManager, accelX, accelY,accelZ);
            CompDCMGyroUpdate(&DCMManager, gyroX, gyroY, gyroZ);
            CompDCMStart(&DCMManager);
			} else{
						CompDCMMagnetoUpdate(&DCMManager, magX, magY,magZ);
            CompDCMAccelUpdate(&DCMManager, accelX, accelY,accelZ);
            CompDCMGyroUpdate(&DCMManager, -gyroX, -gyroY, -gyroZ);			//this is the only change from the startup function. Not sure why the values are negative
            CompDCMUpdate(&DCMManager);
			}
		
			

						PID();

			}
		}
	
		
	
}
